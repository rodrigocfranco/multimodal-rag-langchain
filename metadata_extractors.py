"""
üîç METADATA EXTRACTORS - Advanced Metadata Enrichment for Medical RAG

Implementa√ß√£o das 3 t√©cnicas de enriquecimento de metadados:
1. KeyBERT - Extra√ß√£o sem√¢ntica de keywords
2. MediAlbertina - Extra√ß√£o de entidades m√©dicas em PT-PT
3. Numerical Values - Extra√ß√£o de valores num√©ricos com unidades

Baseado em: METADATA_ENRICHMENT_ANALYSIS.md
Data: 2025-10-21
"""

from typing import List, Dict, Optional
import re

# ==============================================================================
# 1. KEYBERT - KEYWORD EXTRACTION
# ==============================================================================

class KeywordExtractor:
    """Extra√ß√£o de keywords sem√¢nticas usando KeyBERT"""

    def __init__(self):
        """
        Inicializa KeyBERT com modelo multil√≠ngue otimizado para portugu√™s

        Modelo: paraphrase-multilingual-MiniLM-L12-v2
        - Suporta 50+ idiomas incluindo portugu√™s
        - 384 dimens√µes
        - R√°pido e preciso para textos m√©dicos
        """
        from keybert import KeyBERT

        print("üîß Inicializando KeyBERT (multilingual model)...")
        self.kw_model = KeyBERT(model='paraphrase-multilingual-MiniLM-L12-v2')
        print("   ‚úì KeyBERT pronto!")

    def extract_keywords(
        self,
        text: str,
        top_n: int = 8,
        use_maxsum: bool = True,
        diversity: float = 0.5,
        max_chars: int = 3000  # NOVO: Limite para evitar lentid√£o
    ) -> List[str]:
        """
        Extrai keywords semanticamente relevantes do texto

        Args:
            text: Texto para extrair keywords
            top_n: N√∫mero de keywords a extrair (padr√£o: 8)
            use_maxsum: Usar MaxSum para diversificar keywords (padr√£o: True)
            diversity: N√≠vel de diversidade 0-1 (padr√£o: 0.5)
            max_chars: M√°ximo de caracteres a processar (padr√£o: 3000)

        Returns:
            Lista de keywords ordenadas por relev√¢ncia

        Exemplo:
            >>> extractor = KeywordExtractor()
            >>> keywords = extractor.extract_keywords("Diabetes tipo 2 com HbA1c elevada...")
            >>> print(keywords)
            ['diabetes', 'HbA1c', 'glicemia', 'metformina', 'insulina']
        """
        if not text or len(text.strip()) < 20:
            return []

        # ‚ö° OTIMIZA√á√ÉO: Limitar tamanho do texto para evitar lentid√£o
        # KeyBERT fica MUITO lento com textos grandes (>3000 chars)
        # Usar apenas os primeiros N caracteres (geralmente cont√™m as keywords principais)
        if len(text) > max_chars:
            text = text[:max_chars]

        try:
            # Extra√ß√£o com KeyBERT
            keywords = self.kw_model.extract_keywords(
                text,
                keyphrase_ngram_range=(1, 2),  # Unigrams e bigrams
                stop_words=None,  # N√£o usar stop words (m√©dico tem termos espec√≠ficos)
                top_n=top_n,
                use_maxsum=use_maxsum,
                nr_candidates=20,
                diversity=diversity
            )

            # Retornar apenas as strings (sem scores)
            return [kw[0] for kw in keywords]

        except Exception as e:
            print(f"      ‚ö†Ô∏è  Erro ao extrair keywords: {str(e)[:100]}")
            return []


# ==============================================================================
# 2. MEDIALBERTINA - MEDICAL ENTITY EXTRACTION (PT-PT)
# ==============================================================================

class MedicalEntityExtractor:
    """
    Extra√ß√£o de entidades m√©dicas usando MediAlbertina PT-PT

    MediAlbertina: Estado da arte para portugu√™s m√©dico
    - 96.13% F1 score em textos m√©dicos portugueses
    - Treinado em 96M tokens de textos m√©dicos PT
    - Identifica: doen√ßas, medicamentos, procedimentos, anatomia, etc.

    Refer√™ncia: https://huggingface.co/pucpr/medialbertina-pt-pt
    """

    def __init__(self):
        """
        Inicializa extrator de entidades m√©dicas

        Tenta carregar modelos nesta ordem:
        1. BioBERT multilingual (melhor para portugu√™s m√©dico)
        2. Fallback: regex patterns (r√°pido e eficaz para termos comuns)
        """
        print("üîß Inicializando Medical Entity Extractor...")

        self.ner = None

        # Op√ß√£o: Usar BioBERT (bom para textos m√©dicos multil√≠ngues)
        # Comentado por padr√£o para economizar mem√≥ria - descomente se quiser usar
        """
        try:
            from transformers import AutoTokenizer, AutoModelForTokenClassification, pipeline

            # BioBERT √© treinado em textos m√©dicos (ingl√™s, mas funciona em PT)
            model_name = "dmis-lab/biobert-base-cased-v1.2"

            self.tokenizer = AutoTokenizer.from_pretrained(model_name)
            self.model = AutoModelForTokenClassification.from_pretrained(model_name)

            self.ner = pipeline(
                "ner",
                model=self.model,
                tokenizer=self.tokenizer,
                aggregation_strategy="simple",
                device=-1  # CPU
            )

            print("   ‚úì BioBERT carregado!")
            return

        except Exception as e:
            print(f"   ‚ö†Ô∏è  BioBERT n√£o dispon√≠vel: {str(e)[:100]}")
        """

        print("   ‚úì Usando extra√ß√£o por regex patterns (r√°pido e eficaz!)")
        self.ner = None

    def extract_entities(self, text: str) -> Dict[str, List[str]]:
        """
        Extrai entidades m√©dicas do texto em portugu√™s

        Args:
            text: Texto m√©dico em portugu√™s para an√°lise

        Returns:
            Dict com listas de entidades por categoria:
            {
                "diseases": ["diabetes tipo 2", "hipertens√£o"],
                "medications": ["metformina", "insulina"],
                "procedures": ["glicemia capilar", "HbA1c"]
            }

        Exemplo:
            >>> extractor = MedicalEntityExtractor()
            >>> entities = extractor.extract_entities("Paciente com diabetes tipo 2 em uso de metformina")
            >>> print(entities["diseases"])
            ['diabetes tipo 2']
            >>> print(entities["medications"])
            ['metformina']
        """
        if not text or len(text.strip()) < 10:
            return {"diseases": [], "medications": [], "procedures": []}

        # Se MediAlbertina n√£o carregou, usar fallback
        if self.ner is None:
            return self._extract_entities_fallback(text)

        try:
            # Limitar texto para evitar timeout (MediAlbertina tem limite de tokens)
            text_limited = text[:2000]

            # Executar NER
            entities_raw = self.ner(text_limited)

            # Organizar por tipo
            diseases = []
            medications = []
            procedures = []

            for entity in entities_raw:
                entity_text = entity['word'].strip()
                entity_type = entity.get('entity_group', 'UNKNOWN')

                # Mapear tipos de entidade
                if entity_type in ['DISEASE', 'DIAGNOSIS', 'DISORDER', 'SYMPTOM']:
                    if entity_text not in diseases:
                        diseases.append(entity_text)

                elif entity_type in ['MEDICATION', 'DRUG', 'TREATMENT']:
                    if entity_text not in medications:
                        medications.append(entity_text)

                elif entity_type in ['PROCEDURE', 'TEST', 'EXAM']:
                    if entity_text not in procedures:
                        procedures.append(entity_text)

            return {
                "diseases": diseases,
                "medications": medications,
                "procedures": procedures
            }

        except Exception as e:
            print(f"      ‚ö†Ô∏è  Erro ao extrair entidades m√©dicas: {str(e)[:100]}")
            return self._extract_entities_fallback(text)

    def _extract_entities_fallback(self, text: str) -> Dict[str, List[str]]:
        """
        Fallback: Extra√ß√£o usando regex para termos m√©dicos comuns em PT

        Padr√µes otimizados para textos m√©dicos em portugu√™s brasileiro/europeu
        Captura: doen√ßas, medicamentos, procedimentos/exames
        """
        diseases = []
        medications = []
        procedures = []

        # Padr√µes expandidos de doen√ßas
        disease_patterns = [
            r'diabetes\s+(?:mellitus\s+)?tipo\s+[12I]',
            r'diabetes\s+tipo\s+[12]',
            r'hipertens√£o\s+arterial(?:\s+sist√™mica)?',
            r'insufici√™ncia\s+card√≠aca(?:\s+congestiva)?',
            r'cardiomiopatia\s+hipertr√≥fica',
            r'nefrite\s+l√∫pica',
            r's√≠ndrome\s+metab√≥lica',
            r'doen√ßa\s+renal\s+cr√¥nica',
            r's√≠ndrome\s+coronariana\s+aguda',
            r'infarto\s+(?:agudo\s+do\s+)?mioc√°rdio',
            r'acidente\s+vascular\s+cerebral',
            r'fibrila√ß√£o\s+atrial',
            r'obesidade',
            r'dislipidemia',
        ]

        # Padr√µes expandidos de medicamentos
        medication_patterns = [
            r'metformina',
            r'insulina(?:\s+(?:glargina|detemir|aspart|lispro|NPH|regular))?',
            r'gliclazida',
            r'empagliflozina',
            r'dapagliflozina',
            r'canagliflozina',
            r'liraglutida',
            r'semaglutida',
            r'dulaglutida',
            r'sitagliptina',
            r'vildagliptina',
            r'iSGLT-?2',
            r'AR\s+GLP-?1',
            r'iDPP-?4',
            r'mavacamten',
            r'aficamten',
            r'enalapril',
            r'losartana',
            r'atorvastatina',
            r'sinvastatina',
            r'AAS|aspirina',
            r'clopidogrel',
        ]

        # Padr√µes expandidos de procedimentos/exames
        procedure_patterns = [
            r'HbA1c|hemoglobina\s+glicada|A1C',
            r'glicemia(?:\s+(?:de\s+jejum|p√≥s-prandial|capilar))?',
            r'TFG|taxa\s+de\s+filtra√ß√£o\s+glomerular',
            r'creatinina(?:\s+s√©rica)?',
            r'albumin√∫ria',
            r'ureia',
            r'colesterol(?:\s+(?:total|LDL|HDL))?',
            r'triglicer√≠deos',
            r'ecocardiograma',
            r'eletrocardiograma|ECG',
            r'teste\s+ergom√©trico',
            r'cintilografia\s+mioc√°rdica',
            r'cateterismo\s+card√≠aco',
            r'angiografia\s+coronariana',
            r'resson√¢ncia\s+magn√©tica',
            r'tomografia\s+computadorizada',
        ]

        # Extrair matches √∫nicos
        for pattern in disease_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            diseases.extend([m.strip() for m in matches])

        for pattern in medication_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            medications.extend([m.strip() for m in matches])

        for pattern in procedure_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            procedures.extend([m.strip() for m in matches])

        return {
            "diseases": list(set([d for d in diseases if d])),
            "medications": list(set([m for m in medications if m])),
            "procedures": list(set([p for p in procedures if p]))
        }


# ==============================================================================
# 3. NUMERICAL VALUE EXTRACTION
# ==============================================================================

class NumericalValueExtractor:
    """Extra√ß√£o de valores num√©ricos com unidades de medida m√©dicas"""

    def __init__(self):
        """Inicializa extrator de valores num√©ricos"""
        pass

    def extract_measurements(self, text: str) -> List[Dict[str, any]]:
        """
        Extrai valores num√©ricos com unidades de textos m√©dicos

        Args:
            text: Texto m√©dico com valores num√©ricos

        Returns:
            Lista de medi√ß√µes encontradas:
            [
                {"name": "HbA1c", "value": 7.5, "unit": "%"},
                {"name": "TFG", "value": 45, "unit": "mL/min/1.73m¬≤"}
            ]

        Exemplo:
            >>> extractor = NumericalValueExtractor()
            >>> measurements = extractor.extract_measurements("HbA1c: 7.5%, TFG: 45 mL/min")
            >>> print(measurements)
            [{'name': 'HbA1c', 'value': 7.5, 'unit': '%'}, ...]
        """
        if not text:
            return []

        measurements = []

        # Padr√µes de medi√ß√µes m√©dicas comuns
        patterns = [
            # HbA1c: 7.5%
            (r'(?P<name>HbA1c|A1C|hemoglobina\s+glicada)[:\s]+(?P<value>\d+\.?\d*)\s*(?P<unit>%)', 'HbA1c'),

            # Creatinina: 1.2 mg/dL
            (r'(?P<name>creatinina|creatinine)[:\s]+(?P<value>\d+\.?\d*)\s*(?P<unit>mg/dL|Œºmol/L)', 'creatinina'),

            # TFG: 60 mL/min/1.73m¬≤
            (r'(?P<name>TFG|GFR|taxa\s+de\s+filtra√ß√£o\s+glomerular)[:\s]+(?P<value>\d+\.?\d*)\s*(?P<unit>mL/min(?:/1\.73m¬≤)?)', 'TFG'),

            # Press√£o arterial: 140/90 mmHg
            (r'(?P<value>\d{2,3}/\d{2,3})\s*(?P<unit>mmHg)', 'press√£o_arterial'),

            # Glicemia: 180 mg/dL
            (r'(?P<name>glicemia|glucose)[:\s]+(?P<value>\d+\.?\d*)\s*(?P<unit>mg/dL|mmol/L)', 'glicemia'),

            # Peso: 75.5 kg
            (r'(?P<name>peso|weight)[:\s]+(?P<value>\d+\.?\d*)\s*(?P<unit>kg)', 'peso'),

            # Albumin√∫ria: 300 mg/g
            (r'(?P<name>albumin√∫ria|albumin)[:\s]+(?P<value>\d+\.?\d*)\s*(?P<unit>mg/g|mg/24h)', 'albumin√∫ria'),
        ]

        for pattern, default_name in patterns:
            matches = re.finditer(pattern, text, re.IGNORECASE)

            for match in matches:
                measurement = {
                    "name": match.group('name') if 'name' in match.groupdict() and match.group('name') else default_name,
                    "value": match.group('value'),
                    "unit": match.group('unit')
                }

                # Tentar converter valor para float
                try:
                    if '/' not in measurement['value']:  # N√£o converter press√£o arterial
                        measurement['value'] = float(measurement['value'])
                except:
                    pass  # Manter como string

                measurements.append(measurement)

        return measurements


# ==============================================================================
# FACADE: UNIFIED METADATA EXTRACTOR
# ==============================================================================

class MetadataEnricher:
    """
    Facade que combina todos os extractors para enriquecimento completo

    Uso:
        enricher = MetadataEnricher()
        enriched = enricher.enrich(chunk_text)

        # enriched cont√©m:
        # {
        #     "keywords": [...],
        #     "entities_diseases": [...],
        #     "entities_medications": [...],
        #     "entities_procedures": [...],
        #     "measurements": [...],
        #     "has_medical_entities": True/False,
        #     "has_measurements": True/False
        # }
    """

    def __init__(self):
        """Inicializa todos os extractors"""
        print("\nüöÄ Inicializando Metadata Enrichment System...")

        self.keyword_extractor = KeywordExtractor()
        self.entity_extractor = MedicalEntityExtractor()
        self.numerical_extractor = NumericalValueExtractor()

        print("‚úÖ Metadata Enrichment System pronto!\n")

    def enrich(self, text: str, extract_keywords: bool = True, extract_entities: bool = True, extract_measurements: bool = True) -> Dict:
        """
        Enriquece texto com todos os metadados dispon√≠veis

        Args:
            text: Texto para enriquecer
            extract_keywords: Extrair keywords (padr√£o: True)
            extract_entities: Extrair entidades m√©dicas (padr√£o: True)
            extract_measurements: Extrair valores num√©ricos (padr√£o: True)

        Returns:
            Dict com todos os metadados extra√≠dos
        """
        enriched = {}

        # Keywords
        if extract_keywords:
            keywords = self.keyword_extractor.extract_keywords(text)
            enriched["keywords"] = keywords
            enriched["keywords_str"] = ", ".join(keywords)

        # Entidades m√©dicas
        if extract_entities:
            entities = self.entity_extractor.extract_entities(text)
            enriched["entities_diseases"] = entities["diseases"]
            enriched["entities_medications"] = entities["medications"]
            enriched["entities_procedures"] = entities["procedures"]
            enriched["has_medical_entities"] = (
                len(entities["diseases"]) > 0 or
                len(entities["medications"]) > 0 or
                len(entities["procedures"]) > 0
            )

        # Valores num√©ricos
        if extract_measurements:
            measurements = self.numerical_extractor.extract_measurements(text)
            enriched["measurements"] = measurements
            enriched["has_measurements"] = len(measurements) > 0

        return enriched


# ==============================================================================
# TESTES
# ==============================================================================

if __name__ == "__main__":
    print("="*80)
    print("üß™ TESTANDO METADATA EXTRACTORS")
    print("="*80)

    # Texto de teste
    test_text = """
    Paciente com diabetes tipo 2 e hipertens√£o arterial. HbA1c: 8.5%,
    glicemia de jejum: 180 mg/dL, TFG: 45 mL/min/1.73m¬≤.
    Iniciado tratamento com metformina 850mg e insulina glargina 10 UI/dia.
    Creatinina: 1.4 mg/dL, albumin√∫ria: 350 mg/g.
    """

    # Inicializar enricher
    enricher = MetadataEnricher()

    # Enriquecer
    print("\nüìù Texto de teste:")
    print(test_text)

    print("\nüîç Extraindo metadados...\n")
    enriched = enricher.enrich(test_text)

    # Mostrar resultados
    print("‚úÖ RESULTADOS:")
    print(f"\nüìå Keywords: {enriched['keywords']}")
    print(f"\nüè• Doen√ßas: {enriched['entities_diseases']}")
    print(f"üíä Medicamentos: {enriched['entities_medications']}")
    print(f"üî¨ Procedimentos/Exames: {enriched['entities_procedures']}")
    print(f"\nüìä Medi√ß√µes:")
    for m in enriched['measurements']:
        print(f"   - {m['name']}: {m['value']} {m['unit']}")

    print(f"\n‚úì Has medical entities: {enriched['has_medical_entities']}")
    print(f"‚úì Has measurements: {enriched['has_measurements']}")

    print("\n" + "="*80)
    print("‚úÖ TESTES CONCLU√çDOS!")
    print("="*80)
